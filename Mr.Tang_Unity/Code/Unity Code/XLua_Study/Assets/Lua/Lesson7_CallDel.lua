print("*********Lua调用C# 委托和事件 相关知识点***********")

local obj = CS.Lesson7()

-- 委托是用来装函数的
-- 使用C#中的委托，就是用来装Lua函数的
local fun = function()
    print("Lua函数Fun")
end

-- Lua中没有复合运算符号 所以不能直接用 += -= 来添加或移除委托函数
-- obj.del = obj.del + fun -- 添加函数到委托中
-- 如果是第一次添加函数到委托中 因为时nil 不能直接相加
print("*********开始加函数***********")

obj.del = fun -- 第一次添加函数到委托中
obj.del = obj.del + fun -- 第二次添加函数到委托中 就可以直接相加了

obj.del = obj.del + function() -- 也可以添加匿名函数 但是不建议这样做 因为无法移除
    print("匿名函数")
end
obj.del() -- 调用委托 会调用所有添加进去的函数
print("*********开始减函数***********")
obj.del = obj.del - fun -- 从委托中移除函数
obj.del = obj.del - fun -- 再次移除函数 上面加了两个fun函数 这里移除两个

obj.del() -- 调用委托 会调用所有添加进去的函数

obj.del = nil -- 清空委托中的所有函数 用这种方法可以消除匿名函数带来的影响
print("*********清空***********")
obj.del = fun -- 清空过后再用要先=
obj.del() -- 调用委托 此时只打印一次 "Lua函数Fun"

print("*********事件相关***********")
local fun2 = function()
    print("事件加函数")
end
print("*********事件加函数***********")
-- 事件加减函数 和 委托非常不同
-- lua中使用C#事件 加函数 有点类似于成员方法 用冒号事件名("+", 函数) 来添加函数
-- 用冒号事件名("-", 函数) 来移除函数
obj:eventAction("+", fun2) -- 给事件添加函数
obj:eventAction("+", function() -- 也可以添加匿名函数 但是不建议这样做 因为无法移除
    print("事件匿名函数")
end)
obj:DoEvent() -- 调用事件 会调用所有添加进去的函数

print("*********事件减函数***********")
obj:eventAction("-", fun2) -- 从事件中移除函数
obj:DoEvent() -- 调用事件 会调用所有添加进去的函数
print("*********事件清空***********")
-- 事件无法直接清空 因为事件和委托最大的不同点就是 事件外部无法修改事件本身 只能通过添加和移除函数来间接修改事件 想要改变事件本身只能在声明事件的类中进行
-- 所以如果我们要进行置空操作是会失败的 想要清空事件 只能去类中写一个清空事件的方法 然后在lua中调用这个方法来清空事件
obj:clearEvent() -- 调用类中的清空事件方法
obj:DoEvent() -- 调用事件 此时不会有任何输出 因为事件已经被清空